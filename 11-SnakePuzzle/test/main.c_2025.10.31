

#ifndef _ENV_H_
#define _ENV_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SCREEN_WIDTH 40
#define SCREEN_HEIGHT 20
#define MARGIN_X 2
#define MARGIN_Y 2
#define GROUND_Y (SCREEN_HEIGHT - 2)

#define GRAVITY 1
#define MAX_ENTITIES 64
#define MAX_BODY_SNAKE 8
#define MAX_TILES 4
#define MAX_STACKSPRITE 3

// #define LINUX       // Si quieres compilar en linux, por defecto es para windows

#ifndef allocate
#define allocate(A) (A *)malloc(sizeof(A))
#define allocateArray(A, B) (A *)malloc(sizeof(A) * ((B > 0) ? (B) : 1))
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef WORD
typedef unsigned short WORD;
#endif

#endif

#ifndef _CANVAS_H_
#define _CANVAS_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef allocate
#define allocate(A) (A *)malloc(sizeof(A))
#define allocateArray(A, B) (A *)malloc(sizeof(A) * ((B > 0) ? (B) : 1))
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef WORD
typedef unsigned short WORD;
#endif

typedef struct
{
    BYTE color; // foreground (4 bits altos) | background (4 bits bajos)
} Pixel;

typedef struct
{
    int width;
    int height;        // Altura física (en píxeles)
    int logicalHeight; // Altura lógica (en caracteres)
    Pixel *buffer;
} Canvas;

// Funciones base del canvas
Canvas *Canvas_Create(int width, int height)
{
    Canvas *c = allocate(Canvas);
    if (!c)
        return NULL;
    c->width = width;
    c->height = height;
    c->logicalHeight = height / 2;
    int length = width * c->logicalHeight;
    c->buffer = allocateArray(Pixel, length);
    memset(c->buffer, 0, length * sizeof(Pixel));
    return c;
}

void Canvas_Destroy(Canvas *c)
{
    if (c)
    {
        free(c->buffer);
        free(c);
    }
}

#endif

#ifndef _GRAPHIC_H_
#define _GRAPHIC_H_

#define colorGraphic(front, back) printf("\e[%d;%d;%dm", (front & 0x8 ? 1 : 0), ((back & 0x7) + (back & 0x8 ? 100 : 40)), ((front & 0x7) + 30))
#define resetColor() printf("\e[0m")
#define gotoXY(X, Y) printf("\e[%d;%dH", (Y), (X))
#define hidecursor() printf("\e[?25l")
#define showcursor() printf("\e[?25h")
#define cleaner() printf("\e[1;1H\e[2J\e[0m")

#define CHAR_UPPER 0xdf

// COLORES
#define BLACK 0x0
#define RED 0x1
#define GREEN 0x2
#define YELLOW 0x3
#define BLUE 0x4
#define MAGENTA 0x5
#define CYAN 0x6
#define LIGHTGREY 0x7
#define DARKGREY 0x8
#define LIGHTRED 0x9
#define LIGHTGREEN 0xa
#define LIGHTYELLOW 0xb
#define LIGHTBLUE 0xc
#define LIGHTMAGENTA 0xd
#define LIGHTCYAN 0xe
#define WHITE 0xf

void Graphic_UpdatePixelColor(Canvas *c, int x, int logicalY, BYTE newColor, int isUpper)
{
    int index = logicalY * c->width + x;
    if (isUpper)
        c->buffer[index].color = (newColor << 4) | (c->buffer[index].color & 0x0F);
    else
        c->buffer[index].color = (c->buffer[index].color & 0xF0) | (newColor & 0x0F);
}

void Graphic_Clear(Canvas *c, BYTE color)
{
    int length = c->width * c->logicalHeight;
    BYTE combined = (color << 4) | color;
    for (int i = 0; i < length; i++)
        c->buffer[i].color = combined;
}

void Graphic_SetPixel(Canvas *c, int x, int y, BYTE color)
{
    if (x >= 0 && x < c->width && y >= 0 && y < c->height)
    {
        int logicalY = y / 2;
        int isUpper = (y % 2 == 0);
        Graphic_UpdatePixelColor(c, x, logicalY, color, isUpper);
    }
}

void Graphic_SetLine(Canvas *c, int x0, int y0, int x1, int y1, BYTE color)
{
    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);
    int sx = (x0 < x1) ? 1 : -1;
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx - dy;

    while (1)
    {
        Graphic_SetPixel(c, x0, y0, color);
        if (x0 == x1 && y0 == y1)
            break;

        int e2 = 2 * err;
        if (e2 > -dy)
        {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx)
        {
            err += dx;
            y0 += sy;
        }
    }
}

void Graphic_SetLineDot(Canvas *c, int x0, int y0, int x1, int y1, BYTE color)
{
    int drawable = 1;
    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);
    int sx = (x0 < x1) ? 1 : -1;
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx - dy;

    while (1)
    {
        if (drawable)
            Graphic_SetPixel(c, x0, y0, color);

        drawable = !drawable;

        if (x0 == x1 && y0 == y1)
            break;

        int e2 = 2 * err;
        if (e2 > -dy)
        {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx)
        {
            err += dx;
            y0 += sy;
        }
    }
}

void Graphic_Draw(Canvas *c, int startX, int startY)
{
    for (int row = 0; row < c->logicalHeight; row++)
    {
        gotoXY(startX, startY + row);
        for (int col = 0; col < c->width; col++)
        {
            Pixel p = c->buffer[row * c->width + col];
            colorGraphic((p.color >> 4) & 0x0F, p.color & 0x0F);
            putchar(CHAR_UPPER);
        }
    }
    resetColor();
}

void Graphic_SetRectangle(Canvas *c, int x0, int y0, int width, int height, BYTE color)
{
    for (int y = y0; y < y0 + height; y++)
    {
        Graphic_SetLine(c, x0, y, x0 + width, y, color);
    }
}

typedef struct
{
    void (*Clear)(Canvas *, BYTE);
    void (*SetPixel)(Canvas *, int, int, BYTE);
    void (*SetLine)(Canvas *, int, int, int, int, BYTE);
    void (*SetLineDot)(Canvas *, int, int, int, int, BYTE);
    void (*SetRectangle)(Canvas *, int, int, int, int, BYTE);
    void (*Draw)(Canvas *, int, int);
} Graphic;

// Inicializador
static Graphic *Graphic_Init(void)
{
    Graphic *g = allocate(Graphic);
    g->Clear = Graphic_Clear;
    g->SetPixel = Graphic_SetPixel;
    g->SetLine = Graphic_SetLine;
    g->SetLineDot = Graphic_SetLineDot;
    g->SetRectangle = Graphic_SetRectangle;
    g->Draw = Graphic_Draw;
    return g;
}

#endif

#ifndef _GAMEPAD_H_
#define _GAMEPAD_H_
#ifdef LINUX
// Codigo para LINUX
#include <unistd.h> //
#define Sleep(a) usleep(a * 1000)

#include <fcntl.h>
#include <termios.h>
// Captura de teclado
static int _initialized_ = 0;
void init_kbhit()
{
    struct termios oldt, newt;

    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO, F_GETFL) | O_NONBLOCK);
    _initialized_ = 1;
}

int _kbhit()
{
    if (!_initialized_)
    {
        init_kbhit();
    }
    int ch = getchar();
    if (ch != EOF)
    {
        ungetc(ch, stdin);
        return 1;
    }
}
#else
// Codigo para WINDOWS
#include <conio.h>   // _kbhit y _getch
#include <windows.h> //Sleep
#endif

// Constante para GamePAD
#define KEY_UP 72
#define KEY_DOWN 80
#define KEY_LEFT 75
#define KEY_RIGHT 77

#define KEY_ESC 27
#define KEY_SPACE 32
#define KEY_ENTER 13
#define KEY_A 97
#define KEY_B 115
#define KEY_EMPTY 0

int press()
{
    int key = KEY_EMPTY;
    if (_kbhit())
    {
        key = _getch();
        if (key == 224)
        {
            key = _getch();
        }
        switch (key)
        {
        case KEY_UP:
        case KEY_DOWN:
        case KEY_RIGHT:
        case KEY_LEFT:
        case KEY_ESC:
        case KEY_SPACE:
        case KEY_ENTER:
        case KEY_A:
        case KEY_B:
            return key;
        }
    }
    return KEY_EMPTY;
}

#endif

typedef enum
{
    DRAW_PIXEL,
    DRAW_LINE,
    DRAW_RECT
} GraphicDraw;
typedef struct
{
    GraphicDraw tag;
    BYTE color;
    int x0;
    int y0;
    int x1;
    int y1;
} GraphicCommand;

typedef struct
{
    int lenght;
    int size; //{0:8X8,1:8X16,2:16X8,3:16X16}
    GraphicCommand *command;
} SpriteStack;

Canvas *Sprite_Load(SpriteStack *sprite)
{
    int sizeSprite[4][2] = {{8, 8}, {8, 16}, {16, 8}, {16, 16}};
    Canvas *buffer = Canvas_Create(sizeSprite[sprite->size][0], sizeSprite[sprite->size][1]);
    for (int index = 0; index < sprite->lenght; index++)
    {
        GraphicCommand *line = &(sprite->command[index]);
        switch (line->tag)
        {
        case DRAW_PIXEL:
            Graphic_SetPixel(buffer, line->x0, line->y0, line->color);
            break;
        case DRAW_LINE:
            Graphic_SetLine(buffer, line->x0, line->y0, line->x1, line->y1, line->color);
            break;
        case DRAW_RECT:
            Graphic_SetRectangle(buffer, line->x0, line->y0, line->x1, line->y1, line->color);
            break;
        }
    }
    return buffer;
}

/* 🪄 Layer.h — Manejo de capas, scroll y fusión inteligente
 * Compatible con Canvas.h y Graphic.h
 */

#ifndef _LAYER_H_
#define _LAYER_H_
#ifndef TRANSPARENT
#define TRANSPARENT 0x00
#endif

// 🧱 Stack de capas
typedef struct
{
    int count;
    Canvas **list;
} CanvasLayerStack;

CanvasLayerStack *CanvasLayer_Create(int count, int width, int height)
{
    CanvasLayerStack *stack = allocate(CanvasLayerStack);
    if (!stack)
        return NULL;
    stack->count = count;
    stack->list = allocateArray(Canvas *, count);
    for (int i = 0; i < count; i++)
        stack->list[i] = Canvas_Create(width, height);
    return stack;
}

void CanvasLayer_Destroy(CanvasLayerStack *stack)
{
    if (!stack)
        return;
    for (int i = 0; i < stack->count; i++)
        Canvas_Destroy(stack->list[i]);
    free(stack->list);
    free(stack);
}

// 🧩 Canvas_MergerLayer — fusión de capas
// void Canvas_MergeLayer(Canvas *dest, Canvas *src, int dstX, int dstY)
void Canvas_MergeLayer(Canvas *dest, Canvas *src)
{
    if (!dest || !src)
        return;

    for (int sy = 0; sy < src->height; sy++)
    {
        int dy = sy;
        if (dy < 0 || dy >= dest->height)
            continue;

        int srcLogicalY = sy / 2;
        int destLogicalY = dy / 2;
        if (srcLogicalY >= src->logicalHeight || destLogicalY >= dest->logicalHeight)
            continue;

        int destIsUpper = (dy % 2 == 0);

        for (int sx = 0; sx < src->width; sx++)
        {
            int dx = sx;
            if (dx < 0 || dx >= dest->width)
                continue;

            BYTE srcColor = src->buffer[srcLogicalY * src->width + sx].color;
            if (srcColor == TRANSPARENT)
                continue;

            BYTE fg = (srcColor >> 4) & 0x0F;
            BYTE bg = srcColor & 0x0F;
            Pixel *dp = &dest->buffer[destLogicalY * dest->width + dx];

            if (destIsUpper)
            {
                if (fg != 0)
                    dp->color = (fg << 4) | (dp->color & 0x0F);
            }
            else
            {
                if (bg != 0)
                    dp->color = (dp->color & 0xF0) | bg;
            }
        }
    }
}

// 🌊 Canvas_BlitSmooth — desplazamiento de medio carácter
void Canvas_BlitSmooth(Canvas *dest, Canvas *src, int dstX, int dstY)
{
    int halfShift = dstY % 2; // 0 = normal, 1 = desplazado medio carácter

    for (int sy = 0; sy < src->height; sy++)
    {
        int dy = dstY + sy;
        if (dy < 0 || dy >= dest->height)
            continue;

        int srcLogicalY = sy / 2;
        if (srcLogicalY >= src->logicalHeight)
            continue;

        int destLogicalY = dy / 2;
        int nextDestLogicalY = destLogicalY + (halfShift && (dy % 2 == 1) ? 1 : 0);
        if (destLogicalY >= dest->logicalHeight)
            continue;

        int srcIsUpper = (sy % 2 == 0);
        int destIsUpper = (dy % 2 == 0);

        for (int sx = 0; sx < src->width; sx++)
        {
            int dx = dstX + sx;
            if (dx < 0 || dx >= dest->width)
                continue;

            BYTE srcColor = src->buffer[srcLogicalY * src->width + sx].color;
            if (srcColor == TRANSPARENT)
                continue;

            BYTE fg = (srcColor >> 4) & 0x0F;
            BYTE bg = srcColor & 0x0F;

            if (!halfShift)
            {
                // --- Modo normal ---
                Pixel *dp = &dest->buffer[destLogicalY * dest->width + dx];
                if (destIsUpper)
                {
                    if (fg != 0)
                        dp->color = (fg << 4) | (dp->color & 0x0F);
                }
                else
                {
                    if (bg != 0)
                        dp->color = (dp->color & 0xF0) | bg;
                }
            }
            else
            {
                // --- Modo desplazado medio carácter ---
                // Mezclar el píxel superior del src con el píxel inferior del dest
                Pixel *dp1 = &dest->buffer[destLogicalY * dest->width + dx];
                Pixel *dp2 = (nextDestLogicalY < dest->logicalHeight)
                                 ? &dest->buffer[nextDestLogicalY * dest->width + dx]
                                 : NULL;

                if (srcIsUpper)
                {
                    // superior del src → inferior del dest
                    if (fg != 0)
                        dp1->color = (dp1->color & 0xF0) | fg;
                }
                else
                {
                    // inferior del src → superior de la siguiente fila lógica
                    if (dp2 && bg != 0)
                        dp2->color = (bg << 4) | (dp2->color & 0x0F);
                }
            }
        }
    }
}

// 🌀 Canvas_ScrollY — desplazamiento vertical (con wrap opcional)
void Canvas_ScrollY(Canvas *c, int offset, int wrap)
{
    if (!c || offset == 0)
        return;
    int len = c->width * c->logicalHeight;
    Pixel *temp = allocateArray(Pixel, len);
    memset(temp, 0, len * sizeof(Pixel));

    for (int y = 0; y < c->height; y++)
    {
        int ny = y + offset;
        if (wrap)
        {
            ny = (ny + c->height) % c->height;
        }
        if (ny < 0 || ny >= c->height)
            continue;

        int srcLogicalY = y / 2;
        int destLogicalY = ny / 2;
        if (srcLogicalY >= c->logicalHeight || destLogicalY >= c->logicalHeight)
            continue;

        temp[destLogicalY * c->width + 0] = c->buffer[srcLogicalY * c->width + 0];
        memcpy(&temp[destLogicalY * c->width],
               &c->buffer[srcLogicalY * c->width],
               c->width * sizeof(Pixel));
    }

    memcpy(c->buffer, temp, len * sizeof(Pixel));
    free(temp);
}

// 🌀 Canvas_ScrollX — desplazamiento horizontal
void Canvas_ScrollX(Canvas *c, int offset, int wrap)
{
    if (!c || offset == 0)
        return;

    for (int y = 0; y < c->logicalHeight; y++)
    {
        Pixel *row = allocateArray(Pixel, c->width);
        memcpy(row, &c->buffer[y * c->width], c->width * sizeof(Pixel));

        for (int x = 0; x < c->width; x++)
        {
            int nx = x + offset;
            if (wrap)
            {
                nx = (nx + c->width) % c->width;
            }
            if (nx < 0 || nx >= c->width)
                continue;
            c->buffer[y * c->width + nx] = row[x];
        }
        free(row);
    }
}

// 🪄 CanvasLayer_MergeAll — combina todas las capas en una
Canvas *CanvasLayer_MergeAll(CanvasLayerStack *stack)
{
    Canvas *dest;
    if (!stack)
        return NULL;
    dest = Canvas_Create(stack->list[0]->width, stack->list[0]->height);
    for (int i = 0; i < stack->count; i++)
        Canvas_MergeLayer(dest, stack->list[i]);
    return dest;
}

typedef struct
{
    CanvasLayerStack *(*Create)(int, int, int);
    void (*Destroy)(CanvasLayerStack *);
    void (*MergeLayer)(Canvas *, Canvas *);
    void (*MergeCanvas)(Canvas *, Canvas *, int, int);
    void (*ScrollX)(Canvas *, int, int);
    void (*ScrollY)(Canvas *, int, int);
    Canvas *(*Resume)(CanvasLayerStack *);
} Layer;

Layer *Layer_Init(void)
{
    Layer *g = allocate(Layer);
    g->Create = CanvasLayer_Create;
    g->Destroy = CanvasLayer_Destroy;
    g->MergeCanvas = Canvas_BlitSmooth;
    g->MergeLayer = Canvas_MergeLayer;
    g->ScrollX = Canvas_ScrollX;
    g->ScrollY = Canvas_ScrollX;
    g->Resume = CanvasLayer_MergeAll;
    return g;
}
#endif // _LAYER_H_

#ifndef _ENTITY_H_
#define _ENTITY_H_

#ifndef TypeEntity
typedef enum _TE TypeEntity;
#endif

typedef struct
{
    int dx, dy;
    int activo;
} Velocity;

typedef struct
{
    int active;
    int type;
    Velocity vel; // opcionalmente obligatoria
    void *data;   // apunta a la estructura concreta
} Entity_ECS;

typedef struct
{
    int id;
    int count;
    Entity_ECS *player;                 // Extrair Jugador .. reduz complejidad
    Entity_ECS *entities[MAX_ENTITIES]; // OJO Array de punteros
} World_ECS;

// Destruir entidad
void Entity_Destroy(Entity_ECS *e)
{
    if (!e)
        return;
    free(e->data);
    free(e);
}
#endif

#ifndef _ENTITY_SNAKE_H_
#define _ENTITY_SNAKE_H_
typedef enum _TE
{
    ENTITY_NONE,
    ENTITY_SNAKE,    // 🐍 Snake
    ENTITY_FOOD,     // 🍎 Food
    ENTITY_PLATFORM, // 🧱 Wall
    ENTITY_ROCK,     // 🪨 Rock
    ENTITY_SPIKE,    // 🔱 Spike
    ENTITY_EXIT      // 🚪 Door
} TypeEntity;

typedef struct
{
    int x, y;
} PointData;

int EqualPoint(PointData *a, PointData *b)
{
    return a->x == b->x && a->y == b->y;
}

typedef struct
{
    int length;
    int gravityEnabled;
    PointData body[MAX_BODY_SNAKE];
} SnakeData;

Entity_ECS *CreateEntity(TypeEntity type, int x, int y)
{
    Entity_ECS *e = allocate(Entity_ECS);
    e->type = type;
    e->active = 1;

    if (type == ENTITY_SNAKE)
    {
        SnakeData *sd = allocate(SnakeData);
        sd->length = 3;
        for (int i = 0; i < sd->length; i++)
        {
            sd->body[i].x = x - i;
            sd->body[i].y = y;
        }
        sd->gravityEnabled = 1;
        e->data = sd;
    }
    else
    {
        PointData *p = allocate(PointData);
        p->x = x;
        p->y = y;
        e->data = p;
    }
    e->vel.dx = 0;
    e->vel.dy = 0;
    return e;
}
#endif

#ifndef _ENTITY_MAP_H_
#define _ENTITY_MAP_H_
typedef enum
{
    APOINT,
    LINE_HORIZONTAL,
    LINE_VERTICAL
} TypeDraw;

typedef struct
{
    TypeDraw draw;
    TypeEntity entity;
    int x;
    int y;
    int lenght;
} EntityDraw;

typedef struct
{
    int lenght;
    EntityDraw *tiles;
} MapEntity;
#endif

#ifndef _MAPTILES_H_
#define _MAPTILES_H_
MapEntity Map01 = (MapEntity){5, (EntityDraw[5]){
                                     (EntityDraw){APOINT, ENTITY_SNAKE, 8, GROUND_Y - 2},
                                     (EntityDraw){APOINT, ENTITY_FOOD, 9, GROUND_Y - 3},
                                     (EntityDraw){LINE_HORIZONTAL, ENTITY_PLATFORM, 5, GROUND_Y - 1, 17},
                                     (EntityDraw){LINE_HORIZONTAL, ENTITY_PLATFORM, 10, GROUND_Y - 4, 10},
                                     (EntityDraw){APOINT, ENTITY_EXIT, 23, GROUND_Y - 5}}};

MapEntity Map02 = (MapEntity){5, (EntityDraw[5]){
                                     (EntityDraw){APOINT, ENTITY_SNAKE, 8, GROUND_Y - 2},
                                     (EntityDraw){APOINT, ENTITY_ROCK, 9, GROUND_Y - 2},
                                     (EntityDraw){LINE_HORIZONTAL, ENTITY_PLATFORM, 5, GROUND_Y - 1, 10},
                                     (EntityDraw){LINE_HORIZONTAL, ENTITY_PLATFORM, 10, GROUND_Y - 4, 10},
                                     (EntityDraw){APOINT, ENTITY_EXIT, 22, GROUND_Y - 3}}};

MapEntity Map03 = (MapEntity){7, (EntityDraw[7]){
                                     (EntityDraw){APOINT, ENTITY_SPIKE, 9, GROUND_Y - 2},
                                     (EntityDraw){APOINT, ENTITY_FOOD, 5, GROUND_Y - 2},
                                     (EntityDraw){LINE_HORIZONTAL, ENTITY_PLATFORM, 6, GROUND_Y - 3, 3},
                                     (EntityDraw){LINE_HORIZONTAL, ENTITY_PLATFORM, 5, GROUND_Y - 1, 5},
                                     (EntityDraw){LINE_VERTICAL, ENTITY_PLATFORM, 10, GROUND_Y - 3, 3},
                                     (EntityDraw){APOINT, ENTITY_SNAKE, 8, GROUND_Y - 4},
                                     (EntityDraw){APOINT, ENTITY_EXIT, 13, GROUND_Y - 5}}};

// Es una array de punteros que apuntan a los datos estaticos
MapEntity *Tiles[MAX_TILES] = {&Map01, &Map02, &Map03, &Map01};

#endif

SpriteStack Sprite01 = (SpriteStack){5, 0,
                                     (GraphicCommand[5]){
                                         (GraphicCommand){DRAW_LINE, RED, 0, 0, 8, 0},
                                         (GraphicCommand){DRAW_LINE, YELLOW, 0, 1, 8, 1},
                                         (GraphicCommand){DRAW_LINE, GREEN, 0, 2, 8, 2},
                                         (GraphicCommand){DRAW_LINE, CYAN, 0, 3, 8, 3},
                                         (GraphicCommand){DRAW_LINE, BLUE, 0, 4, 8, 4}}};
SpriteStack Sprite02 = (SpriteStack){15, 2,
                                     (GraphicCommand[15]){
                                         (GraphicCommand){DRAW_LINE, WHITE, 1, 0, 13, 0},
                                         (GraphicCommand){DRAW_RECT, WHITE, 0, 1, 14, 4},
                                         (GraphicCommand){DRAW_LINE, WHITE, 1, 5, 13, 5},
                                         (GraphicCommand){DRAW_LINE, DARKGREY, 1, 6, 13, 6},
                                         (GraphicCommand){DRAW_RECT, LIGHTBLUE, 4, 1, 6, 4},
                                         (GraphicCommand){DRAW_RECT, LIGHTCYAN, 4, 1, 5, 3},
                                         (GraphicCommand){DRAW_PIXEL, DARKGREY, 0, 5},
                                         (GraphicCommand){DRAW_PIXEL, DARKGREY, 14, 5},
                                         (GraphicCommand){DRAW_PIXEL, DARKGREY, 12, 1},
                                         (GraphicCommand){DRAW_PIXEL, MAGENTA, 1, 3},
                                         (GraphicCommand){DRAW_PIXEL, MAGENTA, 2, 4},
                                         (GraphicCommand){DRAW_PIXEL, RED, 12, 4},
                                         (GraphicCommand){DRAW_PIXEL, RED, 13, 3},
                                         (GraphicCommand){DRAW_PIXEL, LIGHTGREEN, 2, 1},
                                         (GraphicCommand){DRAW_PIXEL, LIGHTGREY, 13, 1}}};
SpriteStack Sprite03 = (SpriteStack){9, 2,
                                     (GraphicCommand[9]){
                                         (GraphicCommand){DRAW_LINE, LIGHTGREEN, 2, 1, 13, 1},
                                         (GraphicCommand){DRAW_LINE, LIGHTGREEN, 1, 2, 14, 2},
                                         (GraphicCommand){DRAW_LINE, LIGHTGREEN, 0, 3, 15, 3},
                                         (GraphicCommand){DRAW_LINE, GREEN, 0, 4, 15, 4},
                                         (GraphicCommand){DRAW_LINE, GREEN, 1, 5, 14, 5},
                                         (GraphicCommand){DRAW_LINE, GREEN, 2, 6, 13, 6},
                                         (GraphicCommand){DRAW_LINE, BLUE, 3, 7, 13, 7},
                                         (GraphicCommand){DRAW_LINE, BLUE, 0, 5, 2, 7},
                                         (GraphicCommand){DRAW_LINE, BLUE, 14, 6, 15, 5}}};

SpriteStack *DBSprite[MAX_STACKSPRITE] = {&Sprite01, &Sprite02, &Sprite03};

#ifndef _COMPONENT_WORLD_C_
#define _COMPONENT_WORLD_C_

// Component World
//  Inicializar el "MUNDO"
void World_Init(World_ECS *w)
{
    w->id = 0;
    w->count = 0;
    for (int i = 0; i < MAX_ENTITIES; i++)
        w->entities[i] = NULL;
    w->player = NULL;
}

// Crear nueva entidad y devolver índice
int World_CreateEntity(World_ECS *w, TypeEntity type, int x, int y)
{
    if (type == ENTITY_SNAKE)
    {
        w->player = CreateEntity(type, x, y);
        return 0;
    }
    for (int i = 0; i < MAX_ENTITIES; i++)
    {
        if (w->entities[i] == NULL)
        {
            w->entities[i] = CreateEntity(type, x, y);
            w->count++;
            return i;
        }
    }
    return -1; // no hay espacio
}

void World_EntityEnabledByPoint(World_ECS *w, PointData *point, int active)
{
    for (int i = 0; i < w->count; i++)
    {
        if (EqualPoint(w->entities[i]->data, point))
        {
            w->entities[i]->active = active;
            return;
        }
    }
}

void World_Destroy(World_ECS *w)
{
    for (int i = 0; i < w->count; i++)
    {
        Entity_Destroy(w->entities[i]);
        w->entities[i] = NULL;
    }
    Entity_Destroy(w->player);
    w->player = NULL;
    w->count = 0;
}

TypeEntity World_PointCollision(World_ECS *w, PointData *position)
{
    for (int index = 0; index < MAX_ENTITIES; index++)
    {
        Entity_ECS *e = w->entities[index];
        if (!e || !e->active)
            continue;

        PointData *f = (PointData *)e->data;
        if (EqualPoint(f, position))
        {
            return e->type;
        }
    }
    return ENTITY_NONE;
}
typedef struct
{
    void (*Initialize)(World_ECS *);
    int (*CreateEntity)(World_ECS *, TypeEntity, int, int);
    TypeEntity (*Collide)(World_ECS *, PointData *);
    void (*EnabledEntity)(World_ECS *, PointData *, int);
    void (*Destroy)(World_ECS *);
} ComponentWorld;

ComponentWorld ComponentWorld_Init(void)
{
    ComponentWorld world;

    world.Initialize = World_Init;
    world.CreateEntity = World_CreateEntity;
    world.EnabledEntity = World_EntityEnabledByPoint;
    world.Collide = World_PointCollision;
    world.Destroy = World_Destroy;
    return world;
}
#endif

#ifndef _COMPONENT_PLAYER_C_
#define _COMPONENT_PLAYER_C_

// Component Player

// Inicializar Player
void Player_Init(Entity_ECS *e, int x, int y)
{
    e = allocate(Entity_ECS);
    e->type = ENTITY_SNAKE;
    e->active = 1;

    SnakeData *sd = allocate(SnakeData);
    sd->length = 3;
    for (int i = 0; i < sd->length; i++)
    {
        sd->body[i].x = x - i;
        sd->body[i].y = y;
    }
    sd->gravityEnabled = 1;
    e->data = sd;
}

// Colisión snake-tail
TypeEntity SnakeSelfCollision(Entity_ECS *player, PointData *position)
{
    SnakeData *sd = (SnakeData *)player->data;
    PointData *tail = NULL;
    // Recorremos el cuerpo a partir del segundo segmento
    for (int index = 0; index < sd->length; index++)
    {
        tail = &sd->body[index];
        if (EqualPoint(tail, position))
        {
            return ENTITY_SNAKE;
        }
    }
    return ENTITY_NONE;
}

// Move Player
void Player_Move(Entity_ECS *player, int supported)
{
    SnakeData *snake = (SnakeData *)player->data;
    if (!supported)
    {
        player->vel.dx = 0;
        player->vel.dy = GRAVITY;
    }
    // Mover cola siguiendo la cabeza
    if (player->vel.dx || player->vel.dy)
    {
        for (int j = snake->length; j > 0; j--)
        {
            if (supported)
            {
                snake->body[j].x = snake->body[j - 1].x;
                snake->body[j].y = snake->body[j - 1].y;
            }
            else
            {
                snake->body[j].y += GRAVITY; // todo cae
            }
        }
        // Mover cabeza
        snake->body[0].x += player->vel.dx;
        snake->body[0].y += player->vel.dy;
    }
}

typedef struct
{
    void (*Initialize)(Entity_ECS *, int x, int y);
    void (*Moviment)(Entity_ECS *, int);
    TypeEntity (*CollideSelf)(Entity_ECS *player, PointData *position);
    void (*Destroy)(Entity_ECS *);
} ComponentPlayer;

ComponentPlayer ComponentPlayer_Init(void)
{
    ComponentPlayer player;

    player.Initialize = Player_Init;
    player.Moviment = Player_Move;
    player.CollideSelf = SnakeSelfCollision;
    player.Destroy = Entity_Destroy;
    return player;
}

#endif

#ifndef _COMPONENT_MAP_C_
#define _COMPONENT_MAP_C_
// Componentes
// # Map
void MapLoad(World_ECS *w, MapEntity **Tile, ComponentWorld *world, int level)
{
    MapEntity *Map = Tile[level % MAX_TILES];
    for (int index = 0; index < Map->lenght; index++)
    {
        EntityDraw *line = &(Map->tiles[index]);
        switch (line->draw)
        {
        case APOINT:
            world->CreateEntity(w, line->entity, line->x, line->y);
            break;
        case LINE_HORIZONTAL:
            for (int x = 0; x < line->lenght; x++)
            {
                world->CreateEntity(w, line->entity, line->x + x, line->y);
            }
            break;
        case LINE_VERTICAL:
            for (int y = 0; y < line->lenght; y++)
            {
                world->CreateEntity(w, line->entity, line->x, line->y + y);
            }
            break;
        }
    }
    w->id = level;
}

typedef struct C_Map
{
    // void (*Initialize)(MapEntity **);
    void (*Load)(World_ECS *, MapEntity **, ComponentWorld *, int level);
    // void (*Destroy)(MapEntity **);
} ComponentMap;

ComponentMap ComponentMap_Init(void)
{
    ComponentMap m;
    m.Load = MapLoad;
    // player.Destroy = DestroyByEntity;
    return m;
}
#endif

#ifndef _COMPONENTS_C_
#define _COMPONENTS_C_
// Componentes
typedef struct _Component
{
    ComponentWorld world;
    ComponentPlayer player;
    ComponentMap map;
} Component;
Component Component_Init(void)
{
    Component c;
    c.world = ComponentWorld_Init();
    c.player = ComponentPlayer_Init();
    c.map = ComponentMap_Init();
    return c;
}

#endif

#ifndef _SYSTEMS_C_
#define _SYSTEMS_C_

void InputSystem(Entity_ECS *player, int key)
{
    switch (key)
    {
    case KEY_LEFT:
        player->vel.dx = -1;
        break;
    case KEY_RIGHT:
        player->vel.dx = 1;
        break;
    case KEY_UP:
        player->vel.dy = -1;
        break;
    case KEY_DOWN:
        player->vel.dy = 1;
        break;
    }
}

void PhysicsSystem(World_ECS *w, Component *c)
{
    Entity_ECS *player = w->player;
    SnakeData *snake = (SnakeData *)player->data;
    // Verificar si alguna parte está apoyada
    int supported = 0;
    PointData position;
    // Esta soportado por algun elemento
    for (int index = 0; index < snake->length && !supported; index++)
    {
        position.x = snake->body[index].x;
        position.y = snake->body[index].y + 1;
        if (c->world.Collide(w, &position) != ENTITY_NONE)
        {
            supported = 1;
        }
    }

    PointData head = (PointData){snake->body[0].x + player->vel.dx, snake->body[0].y + player->vel.dy};
    // Evite subir sobre si mismo o traspasar paredes
    TypeEntity entity = c->world.Collide(w, &head);
    // Si la posicion esta Ocupada
    if (c->player.CollideSelf(player, &head) == ENTITY_SNAKE)
    {
        player->vel.dx = 0;
        player->vel.dy = 0;
    }
    if (entity != ENTITY_PLATFORM && entity != ENTITY_ROCK)
    {
        c->player.Moviment(player, supported);
    }
    // Reset de velocidades temporales
    player->vel.dx = 0;
    player->vel.dy = 0;
}

int CollisionSystem(World_ECS *w, Component *c)
{
    SnakeData *snake = (SnakeData *)w->player->data;
    PointData *head = &snake->body[0];

    // Caída al vacío
    if (head->y > SCREEN_HEIGHT)
    {
        return 0;
    }
    TypeEntity hit = c->world.Collide(w, head);
    switch (hit)
    {
    case ENTITY_EXIT:
        int level = w->id + 1;
        c->world.Destroy(w);
        c->map.Load(w, Tiles, &(c->world), level);
        break;
    case ENTITY_FOOD:
        c->world.EnabledEntity(w, head, 0);
        snake->length++;
        break;
    }
    return 1;
}

void RenderSystem(World_ECS *w, Graphic *gfx, Canvas *c)
{
    gfx->Clear(c, DARKGREY);
    for (int index = 0; index < w->count; index++)
    {
        Entity_ECS *e = w->entities[index];
        if (!e->active)
            continue;

        PointData *p = (PointData *)e->data;
        BYTE color = WHITE;
        if (e->type == ENTITY_SPIKE)
            color = LIGHTMAGENTA;
        if (e->type == ENTITY_ROCK)
            color = LIGHTGREY;
        if (e->type == ENTITY_FOOD)
            color = LIGHTRED;
        if (e->type == ENTITY_PLATFORM)
            color = YELLOW;
        if (e->type == ENTITY_EXIT)
            color = CYAN;
        gfx->SetPixel(c, p->x, p->y, color);
    }

    SnakeData *sd = (SnakeData *)w->player->data;
    gfx->SetPixel(c, sd->body[0].x, sd->body[0].y, BLUE);
    for (int index = 1; index < sd->length; index++)
    {
        gfx->SetPixel(c, sd->body[index].x, sd->body[index].y, GREEN);
        // gotoXY(2, (SCREEN_HEIGHT / 2) + 2 + index);printf("Player[%d]:{x:%d, y:%d}", index, sd->body[index].x, sd->body[index].y);
    }

    gfx->Draw(c, MARGIN_X + 8, MARGIN_Y);
    gotoXY(1, MARGIN_Y);
    printf("Level %d", w->id + 1);
    resetColor();
}

typedef struct
{
    void (*WatchGamePad)(Entity_ECS *, int);

    void (*Physics)(World_ECS *, Component *);
    int (*Collide)(World_ECS *, Component *);
    void (*Render)(World_ECS *, Graphic *, Canvas *);
    // void (*Destroy)(World_ECS *);
    // void (*Destroy)(Component *);
} System;

System System_Init(void)
{
    System sys;
    sys.WatchGamePad = InputSystem;
    sys.Physics = PhysicsSystem;
    sys.Collide = CollisionSystem;
    sys.Render = RenderSystem;
    return sys;
}

#endif

typedef enum
{
    STATE_OPEN,
    STATE_MENU,
    STATE_START,
    STATE_PAUSE,
    STATE_OVER,
    STATE_END,
    STATE_EXIT
} StateGame;

Canvas *canvas = NULL;
Graphic *gfx = NULL;
Layer *layer = NULL;
CanvasLayerStack *SpriteDB = NULL;

void Sprite_Init(void)
{
    canvas = Canvas_Create(SCREEN_WIDTH, SCREEN_HEIGHT);
    gfx = Graphic_Init();
    layer = Layer_Init();
    //=================================================================
    SpriteDB = allocate(CanvasLayerStack);
    SpriteDB->count = MAX_STACKSPRITE;
    SpriteDB->list = allocateArray(Canvas *, 2);
    for (int index = 0; index < MAX_STACKSPRITE; index++)
    {
        SpriteDB->list[index] = Sprite_Load(DBSprite[index]);
    }
}

void spr(int index, int x, int y)
{
    layer->MergeCanvas(canvas, SpriteDB->list[index], x, y);
}

void Game_init(Component *rules, World_ECS *world)
{
    rules->world.Initialize(world);
    rules->player.Initialize(world->player, 0, 0);
    rules->map.Load(world, Tiles, &rules->world, 0);
}

void Game_Loop(System *system, Component *rules, World_ECS *world, StateGame *running)
{
    int key = press();
    system->WatchGamePad(world->player, key);
    int collide = system->Collide(world, rules);
    system->Physics(world, rules);
    system->Render(world, gfx, canvas);
    (*running) = (collide ? STATE_START : STATE_OVER);
    if (key == KEY_ESC)
    {
        *running = STATE_EXIT;
    }
}

void Open_Render(int step)
{
    if (step == 0)
    {
        gfx->Clear(canvas, BLACK);
        spr(0, 0, 7);
        spr(1, 6, 6);
    }

    if (0 <= step && step <= 18)
    {
        layer->ScrollX(canvas, 2, 0);
        gfx->Draw(canvas, MARGIN_X, MARGIN_Y);
    }
    if (step == 18)
    {
        gotoXY(SCREEN_WIDTH - 16, 11);
        colorGraphic(LIGHTGREY, BLACK);
        printf("8th Son Studio %c", 184);
    }
}

void Menu_Render(int step)
{
    if (step == 0)
    {
        gfx->Clear(canvas, BLACK);
        spr(2, 11, 4); // centro en 6
        gfx->Draw(canvas, MARGIN_X, MARGIN_Y);
        gotoXY(SCREEN_WIDTH - 16, 11);
        colorGraphic(LIGHTGREY, BLACK);
        printf("8th Son Studio %c", 184);
    }

    gotoXY(18, 5);
    colorGraphic(BLACK, LIGHTGREEN);
    printf("cSnake");
    gotoXY(19, 6);
    colorGraphic(WHITE, GREEN);
    printf("Puzzle");

    gotoXY(13, 8);
    colorGraphic(step % 8 < 4 ? CYAN : YELLOW, BLACK);
    printf("Press Enter key");
}

int main()
{
    World_ECS world;
    Component rules = Component_Init();
    System system = System_Init();
    Sprite_Init();

    hidecursor();
    cleaner();

    StateGame running = STATE_OPEN;
    int step = 0;
    while (running != STATE_EXIT)
    {
        switch (running)
        {
        case STATE_OPEN:
            Open_Render(step);
            step++;
            if (step == 32 || press() == KEY_ESC)
            {
                step = 0;
                running = STATE_MENU;
            }

            break;
        case STATE_MENU:
            int option = press();
            Menu_Render(step);
            step = (step + 1) % 255;
            switch (option)
            {
            case KEY_ENTER:
                step = 0;
                running = STATE_START;
                Game_init(&rules, &world);
                resetColor();
                cleaner();
                break;
            case KEY_ESC:
                step = 0;
                running = STATE_EXIT;
                break;
            }

            break;
        case STATE_START:

            Game_Loop(&system, &rules, &world, &running);
            if (running != STATE_START)
            {
                step = 0;
            }
            break;
        case STATE_OVER:
            running = STATE_OPEN;
            resetColor();
            cleaner();
            break;
        }

        Sleep(50);
    }

    rules.world.Destroy(&world);
    showcursor();
    resetColor();
    gotoXY(2, (SCREEN_HEIGHT / 2) + 2);
    printf("Juego terminado.\n");
    return 0;
}